# 优化

> [网站性能优化实战——从12.67s到1.06s的故事](https://juejin.im/post/5b0b7d74518825158e173a0c)

一个网站的性能可以分为两个方面：加载性能 渲染性能
## 加载性能

+ 避免不必要的下载
+ 优化资源大小
+ 图片优化
+ 字体优化
+ Http缓存
+ 延时加载
+ 网页存储
+ 离线存储
+ JS启动优化
  + CSS和JS代码覆盖率
  + 防止内存泄露
  + 分析 webpack 软件包

## 渲染性能

+ 样式计算

## 工具

+ Lighthouse 审查网络应用

## 浏览器处理请求过程

+ 重定向→拉取缓存→DNS查询→建立TCP链接→发起请求→接收响应→处理HTML元素→元素加载完成
## 优化

+ 减少请求数、减小请求资源体积、提升网络传输速率
+ 压缩 js html css
+ 提取公共资源
+ 在服务器上开启Gzip传输压缩, 在 nginx 中配置, 不要对图片文件进行Gzip压缩

  ```text
    gzip on;
    gzip_types text/plain application/javascriptapplication/x-javascripttext/css application/xml text/javascriptapplication/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;
  ```

  + 不是每个浏览器都支持gzip
  + 客户端 http 请求头中有个Accept-Encoding来标识对压缩的支持 `Accept-Encoding: gzip, deflate, br`
  + 客户端http请求头声明浏览器支持的压缩方式，服务端配置启用压缩，压缩的文件类型，压缩方式
  + 响应头 `Response Headers`里有 `Content-Encoding: gzip`， 表示返回数据的压缩类型，客户端自行解压缩
  + 启用 Gzip 需要客户端与服务端都支持
+ 图片资源优化
  + 不要在HTML中缩放图片
  + 使用 CSS Sprite (雪碧图) [生成网址](https://www.toptal.com/developers/css/sprite-generator)
  + 使用字体图标
  + 使用WebP格式
+ 网络传输性能检测工具 Page Speed
+ 使用CDN
+ DNS Prefetch是一种DNS预解析技术，当我们浏览网页时，浏览器会在加载网页时对网页中的域名进行预解析并缓存，这样在浏览器加载网页中的链接时，就无需进行DNS解析，减少用户的等待时间，提高用户体验
+ css dom
  + css 属性读写分离
  + 能过 class 或使用 style.csstest 属性批量操作元素样式
  + dom 元素离线更新
  + 设置元素不可见 visible: hidden, 元素不会响应事件，但会占位
    + opacity: 0; 会响应事件
  + 压缩 dom 深度, css 深度
  + 图片在渲染前指定大小，如不指定，图片加载后会重置宽高，引起页面重排
  + 对页面中可能发生大量重排重绘的元素单独触发渲染层，使用GPU分担CPU压力
    + 动画启用硬件加速：添加3D变换 `rotate3d` `scale3d` `translateZ(0)`
      + 在 Chrome and Safari中，当我们使用CSS transforms 或者 animations时可能会有页面闪烁的效果，下面的代码可以修复此情况 `backface-visibility: hidden; perspective: 1000;`
+ js
  + 使用了闭包后未将相关资源加以释放
  + 引用了外链后未将其置空, 某DOM元素绑定了事件回调，后来却remove了该元素

## seo

+ 页面抓取： 蜘蛛向服务器请求页面，获取页面内容
+ 分析入库：对获取到的内容进行分析，对优质页面进行收录
+ 检索排序：当用户检索关键词时，从收录的页面中按照一定的规则进行排序，并返回给用户结果

# 网络相关

## DNS 预解析

DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

```html
<link rel="dns-prefetch" href="//yuchengkai.cn">
```
## 使用 HTTP / 2.0

因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。

在  HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。

更详细的内容你可以查看 [该小节](../Network/Network-zh.md##http-20)

## 预加载

在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。

预加载其实是声明式的 `fetch` ，强制浏览器请求资源，并且不会阻塞 `onload` 事件，可以使用以下代码开启预加载

```html
<link rel="preload" href="http://example.com">
```

预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。

## 预渲染

可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http://example.com"> 
```

预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染

# 优化渲染过程

对于代码层面的优化，你可以查阅浏览器系列中的 [相关内容](../Browser/browser-ch.md#渲染机制)。

## 懒执行

懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。

## 懒加载

懒加载就是将不关键的资源延后加载。

懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载。

懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。

# 文件优化

## 图片优化

### 计算图片大小

对于一张 100 *100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000* 1 * 4 / 1024）。

但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。

了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：

+ 减少像素点
+ 减少每个像素点能够显示的颜色

### 图片加载优化

1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
3. 小图使用 base64 格式
4. 将多个图标文件整合到一张图片中（雪碧图）
6. 选择正确的图片格式：
   + 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
   + 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   + 照片使用 JPEG

## 其他文件优化

+ CSS 文件放在 `head` 中
+ 服务端开启文件压缩功能
+ 将 `script` 标签放在 `body` 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 `script` 标签放在任意位置然后加上 `defer` ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 `async` ，表示加载和渲染后续文档元素的过程将和  JS 文件的加载与执行并行无序进行。
+ 执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 `Webworker`。`Webworker` 可以让我们另开一个线程执行脚本而不影响渲染。

## CDN

静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。

# 其他

## 使用 Webpack 优化项目

+ 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩
+ 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码
+ 优化图片，对于小图可以使用 base64 的方式写入文件中
+ 按照路由拆分代码，实现按需加载
+ 给打包出来的文件名添加哈希，实现浏览器缓存文件

## 监控

对于代码运行错误，通常的办法是使用 `window.onerror` 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外

+ 对于跨域的代码运行错误会显示 `Script error.` 对于这种情况我们需要给 `script` 标签添加 `crossorigin` 属性
+ 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 `arguments.callee.caller` 来做栈递归

对于异步代码来说，可以使用 `catch` 的方式捕获错误。比如 `Promise` 可以直接使用 `catch` 函数，`async await` 可以使用 `try catch`

但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。

对于捕获的错误需要上传给服务器，通常可以通过 `img` 标签的 `src` 发起一个请求。

## 面试题

**如何渲染几万条数据并不卡住界面**

这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 `requestAnimationFrame` 来每 16 ms 刷新一次。

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <ul>控件</ul>
  <script>
    setTimeout(() => {
      // 插入十万条数据
      const total = 100000
      // 一次插入 20 条，如果觉得性能不好就减少
      const once = 20
      // 渲染数据总共需要几次
      const loopCount = total / once
      let countOfRender = 0
      let ul = document.querySelector("ul");
      function add() {
        // 优化性能，插入不会造成回流
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < once; i++) {
          const li = document.createElement("li");
          li.innerText = Math.floor(Math.random() * total);
          fragment.appendChild(li);
        }
        ul.appendChild(fragment);
        countOfRender += 1;
        loop();
      }
      function loop() {
        if (countOfRender < loopCount) {
          window.requestAnimationFrame(add);
        }
      }
      loop();
    }, 0);
  </script>
</body>
</html>
```
